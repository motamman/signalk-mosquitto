import { PluginServerApp } from '@signalk/server-api';
import { MosquittoPluginConfig, MosquittoManager, MosquittoStatus } from '../types/interfaces';
import { FileUtils } from '../utils/file-utils';
import * as path from 'path';
import { spawn, ChildProcess } from 'child_process';

export class MosquittoManagerImpl implements MosquittoManager {
  private app: PluginServerApp;
  private config: MosquittoPluginConfig;
  private mosquittoProcess: ChildProcess | null = null;
  private configDir: string;
  private dataDir: string;
  private configFile: string;
  private pidFile: string;
  private logFile: string;

  constructor(app: PluginServerApp, config: MosquittoPluginConfig) {
    this.app = app;
    this.config = config;
    this.dataDir = FileUtils.getDataDir('signalk-mosquitto');
    this.configDir = path.join(this.dataDir, 'config');
    this.configFile = path.join(this.configDir, 'mosquitto.conf');
    this.pidFile = path.join(this.dataDir, 'mosquitto.pid');
    this.logFile = path.join(this.dataDir, 'mosquitto.log');
  }

  async start(): Promise<void> {
    try {
      await FileUtils.ensureDir(this.dataDir);
      await FileUtils.ensureDir(this.configDir);

      const configContent = await this.generateConfig(this.config);
      await this.writeConfig(configContent);

      if (!(await this.validateConfig())) {
        throw new Error('Generated configuration is invalid');
      }

      await this.startMosquittoProcess();
      console.log('Mosquitto broker started successfully');
    } catch (error) {
      console.error(`Failed to start Mosquitto: ${(error as Error).message}`);
      throw error;
    }
  }

  async stop(): Promise<void> {
    try {
      if (this.mosquittoProcess) {
        this.mosquittoProcess.kill('SIGTERM');

        const processExited = await FileUtils.waitForProcess(this.mosquittoProcess.pid!, 5000);
        if (!processExited) {
          console.log('Mosquitto process did not exit gracefully, force killing');
          this.mosquittoProcess.kill('SIGKILL');
        }

        this.mosquittoProcess = null;
      }

      const pids = await FileUtils.findProcessByName('mosquitto');
      for (const pid of pids) {
        await FileUtils.killProcess(pid);
      }

      if (await FileUtils.fileExists(this.pidFile)) {
        await FileUtils.deleteFile(this.pidFile);
      }

      console.log('Mosquitto broker stopped');
    } catch (error) {
      console.error(`Error stopping Mosquitto: ${(error as Error).message}`);
      throw error;
    }
  }

  async restart(): Promise<void> {
    await this.stop();
    await new Promise(resolve => setTimeout(resolve, 1000));
    await this.start();
  }

  async getStatus(): Promise<MosquittoStatus> {
    const status: MosquittoStatus = {
      running: false,
      connectedClients: 0,
      totalConnections: 0,
      messagesReceived: 0,
      messagesPublished: 0,
      bytesReceived: 0,
      bytesPublished: 0,
    };

    try {
      const pids = await FileUtils.findProcessByName('mosquitto');
      status.running = pids.length > 0;

      if (status.running && pids.length > 0) {
        status.pid = pids[0];

        try {
          const uptime = await this.getProcessUptime(status.pid);
          status.uptime = uptime;
        } catch (error) {
          console.log(`Failed to get process uptime: ${(error as Error).message}`);
        }

        try {
          const version = await this.getMosquittoVersion();
          status.version = version;
        } catch (error) {
          console.log(`Failed to get Mosquitto version: ${(error as Error).message}`);
        }

        try {
          const stats = await this.getConnectionStats();
          Object.assign(status, stats);
        } catch (error) {
          console.log(`Failed to get connection stats: ${(error as Error).message}`);
        }
      }
    } catch (error) {
      console.error(`Error getting Mosquitto status: ${(error as Error).message}`);
    }

    return status;
  }

  async generateConfig(config: MosquittoPluginConfig): Promise<string> {
    const lines: string[] = [];

    lines.push('# Mosquitto configuration file generated by SignalK plugin');
    lines.push('# Do not edit manually - changes will be overwritten');
    lines.push('');

    lines.push('# Basic configuration');
    lines.push(`port ${config.brokerPort}`);
    lines.push(`bind_address ${config.brokerHost}`);
    lines.push(`max_connections ${config.maxConnections}`);

    if (config.persistence) {
      lines.push('persistence true');
      lines.push(`persistence_location ${config.persistenceLocation}`);
      lines.push('autosave_interval 1800');
    } else {
      lines.push('persistence false');
    }

    if (config.enableLogging) {
      lines.push(`log_dest file ${this.logFile}`);
      lines.push(`log_type ${config.logLevel}`);
      lines.push('log_timestamp true');
    }

    lines.push(`pid_file ${this.pidFile}`);

    if (config.enableWebsockets) {
      lines.push('');
      lines.push('# WebSocket configuration');
      lines.push(`listener ${config.websocketPort}`);
      lines.push('protocol websockets');
    }

    if (config.enableSecurity && !config.allowAnonymous) {
      lines.push('');
      lines.push('# Security configuration');
      lines.push('allow_anonymous false');

      const passwordFile = path.join(this.configDir, 'passwd');
      lines.push(`password_file ${passwordFile}`);

      if (config.acls.length > 0) {
        const aclFile = path.join(this.configDir, 'acl');
        lines.push(`acl_file ${aclFile}`);
      }
    } else {
      lines.push('allow_anonymous true');
    }

    if (config.tlsEnabled && config.tlsCertPath && config.tlsKeyPath) {
      lines.push('');
      lines.push('# TLS configuration');
      lines.push(`certfile ${config.tlsCertPath}`);
      lines.push(`keyfile ${config.tlsKeyPath}`);

      if (config.tlsCaPath) {
        lines.push(`cafile ${config.tlsCaPath}`);
      }

      lines.push('require_certificate false');
      lines.push('use_identity_as_username false');
    }

    if (config.bridges.length > 0) {
      lines.push('');
      lines.push('# Bridge configurations');

      for (const bridge of config.bridges) {
        if (bridge.enabled) {
          lines.push('');
          lines.push(`# Bridge: ${bridge.name}`);
          lines.push(`connection ${bridge.id}`);
          lines.push(`address ${bridge.remoteHost}:${bridge.remotePort}`);

          if (bridge.remoteUsername) {
            lines.push(`remote_username ${bridge.remoteUsername}`);
          }

          if (bridge.remotePassword) {
            lines.push(`remote_password ${bridge.remotePassword}`);
          }

          lines.push(`keepalive_interval ${bridge.keepalive}`);
          lines.push(`cleansession ${bridge.cleanSession}`);
          lines.push(`try_private ${bridge.tryPrivate}`);

          for (const topic of bridge.topics) {
            let topicLine = `topic ${topic.pattern} ${topic.direction} ${topic.qos}`;

            if (topic.localPrefix) {
              topicLine += ` ${topic.localPrefix}`;
            }

            if (topic.remotePrefix) {
              topicLine += ` ${topic.remotePrefix}`;
            }

            lines.push(topicLine);
          }

          if (bridge.tlsEnabled) {
            if (bridge.tlsCertPath) {
              lines.push(`bridge_certfile ${bridge.tlsCertPath}`);
            }
            if (bridge.tlsKeyPath) {
              lines.push(`bridge_keyfile ${bridge.tlsKeyPath}`);
            }
            if (bridge.tlsCaPath) {
              lines.push(`bridge_cafile ${bridge.tlsCaPath}`);
            }
            lines.push('bridge_insecure false');
          }
        }
      }
    }

    return lines.join('\n') + '\n';
  }

  async writeConfig(configContent: string): Promise<void> {
    await FileUtils.writeFile(this.configFile, configContent);
    console.log(`Configuration written to ${this.configFile}`);
  }

  async validateConfig(): Promise<boolean> {
    try {
      const { stderr } = await FileUtils.executeCommand('mosquitto', ['-c', this.configFile, '-t']);

      if (stderr && stderr.includes('Error')) {
        console.error(`Configuration validation failed: ${stderr}`);
        return false;
      }

      return true;
    } catch (error) {
      console.error(`Configuration validation error: ${(error as Error).message}`);
      return false;
    }
  }

  private async startMosquittoProcess(): Promise<void> {
    const mosquittoPath = (await FileUtils.isCommandAvailable('mosquitto'))
      ? 'mosquitto'
      : FileUtils.getMosquittoBinPath();

    this.mosquittoProcess = spawn(mosquittoPath, ['-c', this.configFile], {
      detached: false,
      stdio: ['ignore', 'pipe', 'pipe'],
    });

    this.mosquittoProcess.stdout?.on('data', data => {
      console.log(`Mosquitto stdout: ${data}`);
    });

    this.mosquittoProcess.stderr?.on('data', data => {
      console.log(`Mosquitto stderr: ${data}`);
    });

    this.mosquittoProcess.on('close', code => {
      console.log(`Mosquitto process exited with code ${code}`);
      this.mosquittoProcess = null;
    });

    this.mosquittoProcess.on('error', error => {
      console.error(`Mosquitto process error: ${(error as Error).message}`);
      this.mosquittoProcess = null;
    });

    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Mosquitto start timeout'));
      }, 10000);

      const checkProcess = setInterval(async () => {
        try {
          const pids = await FileUtils.findProcessByName('mosquitto');
          if (pids.length > 0) {
            clearTimeout(timeout);
            clearInterval(checkProcess);
            resolve(void 0);
          }
        } catch (error) {
          clearTimeout(timeout);
          clearInterval(checkProcess);
          reject(error);
        }
      }, 500);
    });
  }

  private async getProcessUptime(pid: number): Promise<number> {
    try {
      const { stdout } = await FileUtils.executeCommand('ps', [
        '-o',
        'etime=',
        '-p',
        pid.toString(),
      ]);
      const etimeStr = stdout.trim();

      const parts = etimeStr.split(':').reverse();
      let seconds = 0;

      if (parts[0]) seconds += parseInt(parts[0]);
      if (parts[1]) seconds += parseInt(parts[1]) * 60;
      if (parts[2]) seconds += parseInt(parts[2]) * 3600;
      if (parts[3]) seconds += parseInt(parts[3]) * 86400;

      return seconds;
    } catch {
      return 0;
    }
  }

  private async getMosquittoVersion(): Promise<string> {
    try {
      const { stdout } = await FileUtils.executeCommand('mosquitto', ['-h']);
      const lines = stdout.split('\n');
      const versionLine = lines.find(line => line.includes('mosquitto version'));

      if (versionLine) {
        const match = versionLine.match(/mosquitto version (\S+)/);
        return match ? match[1] : 'unknown';
      }

      return 'unknown';
    } catch {
      return 'unknown';
    }
  }

  private async getConnectionStats(): Promise<Partial<MosquittoStatus>> {
    return {
      connectedClients: 0,
      totalConnections: 0,
      messagesReceived: 0,
      messagesPublished: 0,
      bytesReceived: 0,
      bytesPublished: 0,
    };
  }

  private async getLinuxDistribution(): Promise<string> {
    try {
      const { stdout } = await FileUtils.executeCommand('cat', ['/etc/os-release']);
      return stdout.toLowerCase();
    } catch {
      return 'unknown';
    }
  }
}
